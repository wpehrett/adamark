//FIXME Warning: EVERYWHERE: ensure created objects are eventually delete'd ("delete <objname>;")!

#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>
#include <list>
#include <vector>
#include <algorithm>
#include <string>
#include <fstream>

//Required headers for simulator operation
#include "prototypes.hpp" //Basic module, message, etc. prototype classes
#include "_system.hpp" //System definition header, auto-generated by per-testcase Python script's config file parsing

using namespace std;

SysCfg* sc;
unsigned int clkGlobal = 0;
bool verbose = 0;
vector<INPUT_TYPE> data_input; //TODO revise to permit string and raw-binary types as well as numeric
vector<OUTPUT_TYPE> data_result_ref; //TODO revise to permit string and raw-binary types as well as numeric
void* data_result;

// Parse an input file to a data vector that can be used to populate a simulated system's initial conditions
// Returns 0 on success, -1 on failure
// TODO add means of permitting (and ignoring) in-file comments, and/or delimeters between logical data values, or something (ex: original machsuite aes)
template <typename T> int parseFile(string filename, vector<T>* dest) {
	ifstream f (filename);
	string l; //TODO test to ensure parsing a string with getline() actually creates a new string object that can be pushed onto the vector!
	if (dest == NULL) {
		printf("Error: cannot read file to null\n");
		return -1;
	}
	if (f.is_open()) {
		while (getline(f, l)) {
			/*size_t first = l.find_first_of("\r\n\t "); // Strip all whitespace
			if (first != string::npos) l.erase(first);*/
			//printf("Line: %s\n", l.c_str());
			
			try { // Try parsing as an int32_t
				T i32 = (T)stoi(l, NULL);
				(*dest).push_back(i32);
			}
			catch (const out_of_range& oor) {
				// Out of range but not invalid argument, so data type should be int64_t instead
				T i64 = (T)stoll(l, NULL);
				(*dest).push_back(i64);
			}
			catch (const invalid_argument& ia1) {
				// Invalid argument, so try double next
				//try {
					T d = (T)stod(l, NULL);
					(*dest).push_back(d);
				//}
				/*catch (const invalid_argument& ia2) {
					// Invalid argument, so last possibility is raw string
					(*dest).push_back(l);
				}*/
			}
			
			//TODO generify data type; parameterize to use raw string, raw binary data, etc.
		}
		f.close();
		return 0;
	}
	else {
		printf("Error: couldn't open file \'%s\'\n", filename.c_str());
		return -1;
	}
}

// Step the simulation loop by one cycle (or, perhaps later/if FIXME'd, until the next event in a queue)
int step() {
	int result = 0;
	
	//TODO: take advantage of the embarrassing parallelism here in phase 1 and then serialize/sync at phase 2
	//In particular: set up a thread pool of size std::thread::hardware_concurrency()
	
	//Phase 1: for each module: process() per current inputs and update energy
	for (int i=0; i<sc->modules.size(); i++) {
		Module* m = sc->modules[i];
		if (verbose) printf("Processing module with id=%d...\n", m->id);
		m->cumulativeEnergy += m->process();
	}
	
	//Phase 2: interconnect: for each module: check outputs, propagate to next module's inputs (or global outputs)
	for (int i=0; i<sc->modules.size(); i++) {
		Module* m = sc->modules[i];
		if (verbose) printf("Examining outputs for module with id=%d...\n", m->id);
		while ((m->outputs).size() > 0) {
			Message* msg = (m->outputs).front();
			int src = msg->src;
			int dest = msg->dest;
			void* data = msg->data;
			if (verbose) printf("Found message: src=%d, dest=%d\n", src, dest);
			
			//Parse and handle messages to system
			if (dest == -1) {
				//Data type must be ThReqParams object
				//TODO gracefully handle error/notify user if incorrect data
				ThReqParams* trp = (ThReqParams*)data;
				switch (trp->type) {
					case Start:
						//TODO handle; this type of message should never be sent from system to testharness
						break;
					case Done: //TODO: consider whether this is actually the best way of checking finish condition (vs if it'd be too weird to handle like this in a Module that's supposed to be representative of real hardware)! 
						//Finish after all remaining messages delivered
						data_result = trp->data;
						result = -1;
						break;
					case GetData:
						//TODO
						break;
					case PutData:
						//TODO
						break;
				}
				delete trp;
				
				//result = data;
				delete msg;
			}
			
			else { //Deliver to another module, rather than to system
				sc->modules[dest]->inputs.push_back(msg);
			}
			
			(m->outputs).pop_front();
		}
	}
	
	//Step 3: update metrics per module activity
	//TODO later (if needed; i.e., if refactor from doing this at the top-level)
	
	return result;
}

int main(int argc, char* argv[]) {
	printf("Hi!\n\n");
	
	string file_in, file_out;
	
	//Parse command-line args
	//TODO make the verbose flag a global, well-defined, well-documented parameter accessible by other, user-defined modules!
	for (int i=1; i<argc; i++) {
		if (strcmp(argv[i], "-v")==0 || strcmp(argv[i], "--verbose")==0) verbose=1;
		else if (strcmp(argv[i], "-i")==0) {
			if (i==argc-1) {
				printf("Error: no argument for input file\n");
				return -1;
			}
			file_in = argv[i+1];
			i++;
		}
		else if (strcmp(argv[i], "-o")==0) {
			if (i==argc-1) {
				printf("Error: no argument for expected-output file\n");
				return -1;
			}
			file_out = argv[i+1];
			i++;
		}
	}
	
	if (parseFile<INPUT_TYPE>(file_in, &data_input) == -1) {
		printf("Error: problem parsing input data! Exiting.\n");
		return -1;
	}
	
	if (parseFile<OUTPUT_TYPE>(file_out, &data_result_ref) == -1) {
		printf("Error: problem parsing expected-output data! Exiting.\n");
		return -1;
	}
	
	//Init: instantiate system
	sc = new SysCfg();
	if (sc->cleanList() == -1) {
		printf("Error: problem with module IDs (non-unique and/or non-sequential)! Exiting.\n");
		return -1;
	}
	
	//Init: set up inputs
	printf("Initializing...\n");
	for (int i=0; i<sc->mod_init_ids.size(); i++) {
		Module* m = sc->modules[sc->mod_init_ids[i]];
		m->init((void*)&data_input[0], data_input.size()*sizeof(INPUT_TYPE));
	}
	
	printf("Beginning simulation...\n");
	//Send Start flag(s)
	for (int i=0; i<sc->mod_init_ids.size(); i++) {
		int this_id = sc->mod_init_ids[i];
		Module* m = sc->modules[this_id];
		m->inputs.push_back(new Message((void*)(new ThReqParams(Start, NULL, 0)), -1, this_id));
	}
	
	//Sim loop: step(), check if done after each step, break when done
	while(1) {
		if (verbose) printf("**** CYCLE %d ****\n", clkGlobal);
		int result = step();
		if (result == -1) {
			printf("Done signal detected\n\n");		
			break;
		}
		//if (clkGlobal > 100) { if (verbose) printf("\n"); break; } //FIXME comment out for non-testing, uncomment to view results for just a few simulated cycles at once
		clkGlobal++;
		if (verbose) printf("\n");
	}
	
	//Check results
	//FIXME parameterize to permit a testcase-defined output comparison function
	//TODO check nulls
	if (memcmp(&data_result_ref[0], data_result, data_result_ref.size()*sizeof(OUTPUT_TYPE))) {
		printf("Error: output differs from expected!\n");
	}
	else printf("Output comparison successful!\n");
	//free(data_result); //We don't care if this leaks since we're ending the program anyway, and a module designer may send us a pointer to a stack-allocated something that we *can't* free
	
	//Cleanup: compute final metrics, display results, exit
	printf("Simulation complete, cleaning up...\n");
	double totalEnergy = 0.0;
	for (int i=0; i<sc->modules.size(); i++) {
		Module* m = sc->modules[i];
		if (verbose) printf("Metrics for module with id=%d...\n", m->id);
		printf("Energy for module with id=%d: %.6f nJ\n", m->id, m->cumulativeEnergy);
		totalEnergy += m->cumulativeEnergy;
	}
	printf("Total energy: %.6f nJ\n", totalEnergy);
	printf("Total cycles: %d\n", clkGlobal+1); //note clkGlobal is 0-indexed, so add 1 to get the total # cycles executed
	
	delete sc;
	
	return 0;
}
/************************/
