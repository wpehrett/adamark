//FIXME Warning: EVERYWHERE: ensure created objects are eventually delete'd ("delete <objname>;")!

#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>
#include <list>
#include <vector>
#include <algorithm>
#include <string>
#include <fstream>

//Required headers for simulator operation
#include "prototypes.hpp" //Basic module, message, etc. prototype classes
#include "_system.hpp" //System definition header, auto-generated by Python config file parser script. DO NOT MODIFY THIS FILE!
//FIXME: Refactor to include this file/structure!

/*//#include your custom module headers here
#include "simplememory.hpp"*/

using namespace std;

SysCfg* sc;
unsigned int clkGlobal = 0;
bool verbose = 0;
vector<int32_t> data_input;
vector<int32_t> data_result_ref;
void* data_result;
//void* data_input;
//void* data_output; //TODO make a dynamically resizing array of arbitrary/testcase-defined type
//TODO: make an abstract object template for "testcase" and then dynamically type all this stuff based upon the instantiated testcase's input/output/etc types?!?!

int parseFile(string filename, vector<int>* dest) { //TODO generify to different data types, incl throughout function
	ifstream f (filename);
	string l;
	if (dest == NULL) {
		printf("Error: cannot read file to null\n");
		return -1;
	}
	if (f.is_open()) {
		//getline(f, l); //For now, should only be "int"; TODO add proper parsing/casing!
		while (getline(f, l)) {
			size_t first = l.find_first_of("\r\n\t ");
			if (first != string::npos) l.erase(first);
			//printf("Line: %s\n", l.c_str());
			(*dest).push_back(stoi(l, NULL));
		}
		f.close();
		return 0;
	}
	else {
		printf("Error: couldn't open file \'%s\'\n", filename.c_str());
		return -1;
	}
}

/*void init() {
	//Set global input to first module
	//TODO generalize this
	int* testint = (int*)malloc(sizeof(int));
	*testint = 2;
	(*modules.begin())->inputs.push_back(new Message((void*)(new MemReqParams(0, sizeof(int), true, (void*)testint)), -1, 0));
	(*modules.begin())->inputs.push_back(new Message((void*)(new MemReqParams(0, sizeof(int), false, NULL)), -1, 0));
}*/

int step() {
	int result = 0;
	
	//Phase 1: for each module: process() per current inputs and update energy
	for (int i=0; i<sc->modules.size(); i++) {
		Module* m = sc->modules[i];
		if (verbose) printf("Processing module with id=%d...\n", m->id);
		m->cumulativeEnergy += m->process();
	}
	
	//Phase 2: interconnect: for each module: check outputs, propagate to next module's inputs (or global outputs)
	//TODO revise/generalize
	for (int i=0; i<sc->modules.size(); i++) {
		Module* m = sc->modules[i];
		if (verbose) printf("Examining outputs for module with id=%d...\n", m->id);
		while ((m->outputs).size() > 0) {
			Message* msg = (m->outputs).front();
			int src = msg->src;
			int dest = msg->dest;
			void* data = msg->data;
			if (verbose) printf("Found message: src=%d, dest=%d\n", src, dest);
			
			//Parse and handle messages to system
			if (dest == -1) {
				//Data type must be ThReqParams object
				ThReqParams* trp = (ThReqParams*)data;
				switch (trp->type) {
					case Start:
						//TODO
						break;
					case Done: //TODO: consider whether this is actually the best way of checking finish condition (vs if it'd be too weird to handle like this in a Module that's supposed to be representative of real hardware)! 
					/*(
					FIXME: A better way would probably be:
					1) do the event-based thing and then finish when the event queue is completely empty... implement as a linked-list with O(n) insertion and O(1) removal, where n=length of event queue, instead of the current module loop where every cycle is O(m) (where m=total number of total modules in the system)
						- Another potential benefit here: would permit simple same-cycle data xfer (if, e.g., want to simulate multiple submodules where some may feed data into others in the same cycle
					2) maybe do a hybrid where modules are scanned each cycle, but they can be skipped by setting a flag in a statically sized bitmask to tell whether they're stalled or on-delay until a later cycle? or have an m-sized int array where each value is the cycle on which the module will next need attention, then check that vs the current cycle count each sim step?
					So, the key questions to ask are:
					a) How many modules do we expect to have?
					b) How active are those modules on average?
					c) How long do we expect the event queues to become, and stretching how far into future time?
					d) If sticking with the check-every-cycle model, or if doing (2), how can the system supply a "done" signal without breaking the "correctness"/realism of the simulation?
						- Maybe a meta-module at the front- and back-end of the simulated system, user-defined, that are designed to do this checking and handle all direct testharness interactions?
					)*/
						//Finish after all remaining messages delivered
						data_result = trp->data;
						result = -1;
						break;
					case GetData:
						//TODO
						break;
					case PutData:
						//TODO
						break;
				}
				delete trp;
				
				//result = data;
			}
			
			delete msg;
			(m->outputs).pop_front();
		}
	}
	
	//Step 3: update metrics per module activity
	//TODO later (if needed; i.e., if not done at top-level)
	
	return result;
}

int main(int argc, char* argv[]) {
	printf("Hi!\n\n");
	
	string file_in, file_out;
	
	//Parse command-line args
	//TODO allow plaintext system configuration files, specification of particular tests or test subsets, etc.
	//TODO make the verbose flag a global, well-defined, well-documented parameter accessible by other, user-defined modules!
	for (int i=1; i<argc; i++) {
		if (strcmp(argv[i], "-v")==0 || strcmp(argv[i], "--verbose")==0) verbose=1;
		else if (strcmp(argv[i], "-i")==0) {
			if (i==argc-1) {
				printf("Error: no argument for input file\n");
				return -1;
			}
			file_in = argv[i+1];
			i++;
		}
		else if (strcmp(argv[i], "-o")==0) {
			if (i==argc-1) {
				printf("Error: no argument for expected-output file\n");
				return -1;
			}
			file_out = argv[i+1];
			i++;
		}
	}
	
	if (parseFile(file_in, &data_input) == -1) {
		printf("Error: problem parsing input data! Exiting.\n");
		return -1;
	}
	
	if (parseFile(file_out, &data_result_ref) == -1) {
		printf("Error: problem parsing expected-output data! Exiting.\n");
		return -1;
	}
	
	//Init: instantiate system
	sc = new SysCfg();
	//sc->mod_init (module*)
	//sc->modules (vector of module*)
	if (sc->cleanList() == -1) {
		printf("Error: problem with module IDs (non-unique and/or non-sequential)! Exiting.\n");
		return -1;
	}
	
	//Init: set up inputs
	printf("Initializing...\n");
	sc->mod_init->init((void*)&data_input[0], 2048); //TODO un-hardcode this!
	
	//Sim loop: step(), check if done after each step, break when done
	printf("Beginning simulation...\n");
	//Send Start flag
	sc->mod_init->inputs.push_back(new Message((void*)(new ThReqParams(Start, NULL, 0)), -1, sc->mod_start_id));
	while(1) {
		if (verbose) printf("**** CYCLE %d ****\n", clkGlobal);
		int result = step();
		if (result == -1) {
			printf("Done signal detected\n\n");		
			break;
		}
		//if (clkGlobal > 10) { if (verbose) printf("\n"); break; } //FIXME remove for non-testing
		clkGlobal++;
		if (verbose) printf("\n");
	}
	
	//Check results
	if (memcmp(&data_result_ref[0], data_result, 2048*sizeof(int32_t))) { //TODO un-hardcode this!
		printf("Error: output differs from expected!\n");
	}
	else printf("Output comparison successful!\n");
	free(data_result);
	
	//Cleanup: compute final metrics, display results, exit
	printf("Simulation complete, cleaning up...\n");
	double totalEnergy = 0.0;
	for (int i=0; i<sc->modules.size(); i++) {
		Module* m = sc->modules[i];
		if (verbose) printf("Metrics for module with id=%d...\n", m->id);
		printf("Energy for module with id=%d: %.6f nJ\n", m->id, m->cumulativeEnergy);
		totalEnergy += m->cumulativeEnergy;
	}
	printf("Total energy: %.6f nJ\n", totalEnergy);
	printf("Total cycles: %d\n", clkGlobal+1); //note clkGlobal is 0-indexed, so add 1 to get the total # cycles executed
	
	//delete sm;
	delete sc;
	
	return 0;
}
/************************/
